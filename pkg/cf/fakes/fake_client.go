/*
 *  Copyright 2022 VMware, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *  http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"io"
	"net/http"
	"net/url"
	"sync"

	cfclient "github.com/cloudfoundry-community/go-cfclient"
	"github.com/vmware-tanzu/app-migrator-for-cloud-foundry/pkg/cf"
)

type FakeClient struct {
	AppByNameStub        func(string, string, string) (cfclient.App, error)
	appByNameMutex       sync.RWMutex
	appByNameArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
	}
	appByNameReturns struct {
		result1 cfclient.App
		result2 error
	}
	appByNameReturnsOnCall map[int]struct {
		result1 cfclient.App
		result2 error
	}
	BindRouteStub        func(string, string) error
	bindRouteMutex       sync.RWMutex
	bindRouteArgsForCall []struct {
		arg1 string
		arg2 string
	}
	bindRouteReturns struct {
		result1 error
	}
	bindRouteReturnsOnCall map[int]struct {
		result1 error
	}
	CreateAppStub        func(cfclient.AppCreateRequest) (cfclient.App, error)
	createAppMutex       sync.RWMutex
	createAppArgsForCall []struct {
		arg1 cfclient.AppCreateRequest
	}
	createAppReturns struct {
		result1 cfclient.App
		result2 error
	}
	createAppReturnsOnCall map[int]struct {
		result1 cfclient.App
		result2 error
	}
	CreateOrgStub        func(cfclient.OrgRequest) (cfclient.Org, error)
	createOrgMutex       sync.RWMutex
	createOrgArgsForCall []struct {
		arg1 cfclient.OrgRequest
	}
	createOrgReturns struct {
		result1 cfclient.Org
		result2 error
	}
	createOrgReturnsOnCall map[int]struct {
		result1 cfclient.Org
		result2 error
	}
	CreateRouteStub        func(cfclient.RouteRequest) (cfclient.Route, error)
	createRouteMutex       sync.RWMutex
	createRouteArgsForCall []struct {
		arg1 cfclient.RouteRequest
	}
	createRouteReturns struct {
		result1 cfclient.Route
		result2 error
	}
	createRouteReturnsOnCall map[int]struct {
		result1 cfclient.Route
		result2 error
	}
	CreateServiceBindingStub        func(string, string) (*cfclient.ServiceBinding, error)
	createServiceBindingMutex       sync.RWMutex
	createServiceBindingArgsForCall []struct {
		arg1 string
		arg2 string
	}
	createServiceBindingReturns struct {
		result1 *cfclient.ServiceBinding
		result2 error
	}
	createServiceBindingReturnsOnCall map[int]struct {
		result1 *cfclient.ServiceBinding
		result2 error
	}
	CreateSpaceStub        func(cfclient.SpaceRequest) (cfclient.Space, error)
	createSpaceMutex       sync.RWMutex
	createSpaceArgsForCall []struct {
		arg1 cfclient.SpaceRequest
	}
	createSpaceReturns struct {
		result1 cfclient.Space
		result2 error
	}
	createSpaceReturnsOnCall map[int]struct {
		result1 cfclient.Space
		result2 error
	}
	DeleteAppStub        func(string) error
	deleteAppMutex       sync.RWMutex
	deleteAppArgsForCall []struct {
		arg1 string
	}
	deleteAppReturns struct {
		result1 error
	}
	deleteAppReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteOrgStub        func(string, bool, bool) error
	deleteOrgMutex       sync.RWMutex
	deleteOrgArgsForCall []struct {
		arg1 string
		arg2 bool
		arg3 bool
	}
	deleteOrgReturns struct {
		result1 error
	}
	deleteOrgReturnsOnCall map[int]struct {
		result1 error
	}
	DoStub        func(*http.Request) (*http.Response, error)
	doMutex       sync.RWMutex
	doArgsForCall []struct {
		arg1 *http.Request
	}
	doReturns struct {
		result1 *http.Response
		result2 error
	}
	doReturnsOnCall map[int]struct {
		result1 *http.Response
		result2 error
	}
	DoRequestStub        func(*cfclient.Request) (*http.Response, error)
	doRequestMutex       sync.RWMutex
	doRequestArgsForCall []struct {
		arg1 *cfclient.Request
	}
	doRequestReturns struct {
		result1 *http.Response
		result2 error
	}
	doRequestReturnsOnCall map[int]struct {
		result1 *http.Response
		result2 error
	}
	DoWithRetryStub        func(func() error) error
	doWithRetryMutex       sync.RWMutex
	doWithRetryArgsForCall []struct {
		arg1 func() error
	}
	doWithRetryReturns struct {
		result1 error
	}
	doWithRetryReturnsOnCall map[int]struct {
		result1 error
	}
	GetStub        func(string) ([]byte, error)
	getMutex       sync.RWMutex
	getArgsForCall []struct {
		arg1 string
	}
	getReturns struct {
		result1 []byte
		result2 error
	}
	getReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	GetAppByGuidNoInlineCallStub        func(string) (cfclient.App, error)
	getAppByGuidNoInlineCallMutex       sync.RWMutex
	getAppByGuidNoInlineCallArgsForCall []struct {
		arg1 string
	}
	getAppByGuidNoInlineCallReturns struct {
		result1 cfclient.App
		result2 error
	}
	getAppByGuidNoInlineCallReturnsOnCall map[int]struct {
		result1 cfclient.App
		result2 error
	}
	GetClientConfigStub        func() *cfclient.Config
	getClientConfigMutex       sync.RWMutex
	getClientConfigArgsForCall []struct {
	}
	getClientConfigReturns struct {
		result1 *cfclient.Config
	}
	getClientConfigReturnsOnCall map[int]struct {
		result1 *cfclient.Config
	}
	GetDomainByNameStub        func(string) (cfclient.Domain, error)
	getDomainByNameMutex       sync.RWMutex
	getDomainByNameArgsForCall []struct {
		arg1 string
	}
	getDomainByNameReturns struct {
		result1 cfclient.Domain
		result2 error
	}
	getDomainByNameReturnsOnCall map[int]struct {
		result1 cfclient.Domain
		result2 error
	}
	GetOrgByGuidStub        func(string) (cfclient.Org, error)
	getOrgByGuidMutex       sync.RWMutex
	getOrgByGuidArgsForCall []struct {
		arg1 string
	}
	getOrgByGuidReturns struct {
		result1 cfclient.Org
		result2 error
	}
	getOrgByGuidReturnsOnCall map[int]struct {
		result1 cfclient.Org
		result2 error
	}
	GetOrgByNameStub        func(string) (cfclient.Org, error)
	getOrgByNameMutex       sync.RWMutex
	getOrgByNameArgsForCall []struct {
		arg1 string
	}
	getOrgByNameReturns struct {
		result1 cfclient.Org
		result2 error
	}
	getOrgByNameReturnsOnCall map[int]struct {
		result1 cfclient.Org
		result2 error
	}
	GetOrgQuotaByNameStub        func(string) (cfclient.OrgQuota, error)
	getOrgQuotaByNameMutex       sync.RWMutex
	getOrgQuotaByNameArgsForCall []struct {
		arg1 string
	}
	getOrgQuotaByNameReturns struct {
		result1 cfclient.OrgQuota
		result2 error
	}
	getOrgQuotaByNameReturnsOnCall map[int]struct {
		result1 cfclient.OrgQuota
		result2 error
	}
	GetSharedDomainByNameStub        func(string) (cfclient.SharedDomain, error)
	getSharedDomainByNameMutex       sync.RWMutex
	getSharedDomainByNameArgsForCall []struct {
		arg1 string
	}
	getSharedDomainByNameReturns struct {
		result1 cfclient.SharedDomain
		result2 error
	}
	getSharedDomainByNameReturnsOnCall map[int]struct {
		result1 cfclient.SharedDomain
		result2 error
	}
	GetSpaceByGuidStub        func(string) (cfclient.Space, error)
	getSpaceByGuidMutex       sync.RWMutex
	getSpaceByGuidArgsForCall []struct {
		arg1 string
	}
	getSpaceByGuidReturns struct {
		result1 cfclient.Space
		result2 error
	}
	getSpaceByGuidReturnsOnCall map[int]struct {
		result1 cfclient.Space
		result2 error
	}
	GetSpaceByNameStub        func(string, string) (cfclient.Space, error)
	getSpaceByNameMutex       sync.RWMutex
	getSpaceByNameArgsForCall []struct {
		arg1 string
		arg2 string
	}
	getSpaceByNameReturns struct {
		result1 cfclient.Space
		result2 error
	}
	getSpaceByNameReturnsOnCall map[int]struct {
		result1 cfclient.Space
		result2 error
	}
	GetStackByGuidStub        func(string) (cfclient.Stack, error)
	getStackByGuidMutex       sync.RWMutex
	getStackByGuidArgsForCall []struct {
		arg1 string
	}
	getStackByGuidReturns struct {
		result1 cfclient.Stack
		result2 error
	}
	getStackByGuidReturnsOnCall map[int]struct {
		result1 cfclient.Stack
		result2 error
	}
	HTTPClientStub        func() *http.Client
	hTTPClientMutex       sync.RWMutex
	hTTPClientArgsForCall []struct {
	}
	hTTPClientReturns struct {
		result1 *http.Client
	}
	hTTPClientReturnsOnCall map[int]struct {
		result1 *http.Client
	}
	ListAppsByQueryStub        func(url.Values) ([]cfclient.App, error)
	listAppsByQueryMutex       sync.RWMutex
	listAppsByQueryArgsForCall []struct {
		arg1 url.Values
	}
	listAppsByQueryReturns struct {
		result1 []cfclient.App
		result2 error
	}
	listAppsByQueryReturnsOnCall map[int]struct {
		result1 []cfclient.App
		result2 error
	}
	ListOrgsStub        func() ([]cfclient.Org, error)
	listOrgsMutex       sync.RWMutex
	listOrgsArgsForCall []struct {
	}
	listOrgsReturns struct {
		result1 []cfclient.Org
		result2 error
	}
	listOrgsReturnsOnCall map[int]struct {
		result1 []cfclient.Org
		result2 error
	}
	ListOrgsByQueryStub        func(url.Values) ([]cfclient.Org, error)
	listOrgsByQueryMutex       sync.RWMutex
	listOrgsByQueryArgsForCall []struct {
		arg1 url.Values
	}
	listOrgsByQueryReturns struct {
		result1 []cfclient.Org
		result2 error
	}
	listOrgsByQueryReturnsOnCall map[int]struct {
		result1 []cfclient.Org
		result2 error
	}
	ListRoutesByQueryStub        func(url.Values) ([]cfclient.Route, error)
	listRoutesByQueryMutex       sync.RWMutex
	listRoutesByQueryArgsForCall []struct {
		arg1 url.Values
	}
	listRoutesByQueryReturns struct {
		result1 []cfclient.Route
		result2 error
	}
	listRoutesByQueryReturnsOnCall map[int]struct {
		result1 []cfclient.Route
		result2 error
	}
	ListServiceInstancesByQueryStub        func(url.Values) ([]cfclient.ServiceInstance, error)
	listServiceInstancesByQueryMutex       sync.RWMutex
	listServiceInstancesByQueryArgsForCall []struct {
		arg1 url.Values
	}
	listServiceInstancesByQueryReturns struct {
		result1 []cfclient.ServiceInstance
		result2 error
	}
	listServiceInstancesByQueryReturnsOnCall map[int]struct {
		result1 []cfclient.ServiceInstance
		result2 error
	}
	ListSpacesStub        func() ([]cfclient.Space, error)
	listSpacesMutex       sync.RWMutex
	listSpacesArgsForCall []struct {
	}
	listSpacesReturns struct {
		result1 []cfclient.Space
		result2 error
	}
	listSpacesReturnsOnCall map[int]struct {
		result1 []cfclient.Space
		result2 error
	}
	ListSpacesByQueryStub        func(url.Values) ([]cfclient.Space, error)
	listSpacesByQueryMutex       sync.RWMutex
	listSpacesByQueryArgsForCall []struct {
		arg1 url.Values
	}
	listSpacesByQueryReturns struct {
		result1 []cfclient.Space
		result2 error
	}
	listSpacesByQueryReturnsOnCall map[int]struct {
		result1 []cfclient.Space
		result2 error
	}
	ListStacksByQueryStub        func(url.Values) ([]cfclient.Stack, error)
	listStacksByQueryMutex       sync.RWMutex
	listStacksByQueryArgsForCall []struct {
		arg1 url.Values
	}
	listStacksByQueryReturns struct {
		result1 []cfclient.Stack
		result2 error
	}
	listStacksByQueryReturnsOnCall map[int]struct {
		result1 []cfclient.Stack
		result2 error
	}
	ListUserProvidedServiceInstancesByQueryStub        func(url.Values) ([]cfclient.UserProvidedServiceInstance, error)
	listUserProvidedServiceInstancesByQueryMutex       sync.RWMutex
	listUserProvidedServiceInstancesByQueryArgsForCall []struct {
		arg1 url.Values
	}
	listUserProvidedServiceInstancesByQueryReturns struct {
		result1 []cfclient.UserProvidedServiceInstance
		result2 error
	}
	listUserProvidedServiceInstancesByQueryReturnsOnCall map[int]struct {
		result1 []cfclient.UserProvidedServiceInstance
		result2 error
	}
	NewRequestStub        func(string, string) *cfclient.Request
	newRequestMutex       sync.RWMutex
	newRequestArgsForCall []struct {
		arg1 string
		arg2 string
	}
	newRequestReturns struct {
		result1 *cfclient.Request
	}
	newRequestReturnsOnCall map[int]struct {
		result1 *cfclient.Request
	}
	NewRequestWithBodyStub        func(string, string, io.Reader) *cfclient.Request
	newRequestWithBodyMutex       sync.RWMutex
	newRequestWithBodyArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 io.Reader
	}
	newRequestWithBodyReturns struct {
		result1 *cfclient.Request
	}
	newRequestWithBodyReturnsOnCall map[int]struct {
		result1 *cfclient.Request
	}
	TargetStub        func() string
	targetMutex       sync.RWMutex
	targetArgsForCall []struct {
	}
	targetReturns struct {
		result1 string
	}
	targetReturnsOnCall map[int]struct {
		result1 string
	}
	UpdateAppStub        func(string, cfclient.AppUpdateResource) (cfclient.UpdateResponse, error)
	updateAppMutex       sync.RWMutex
	updateAppArgsForCall []struct {
		arg1 string
		arg2 cfclient.AppUpdateResource
	}
	updateAppReturns struct {
		result1 cfclient.UpdateResponse
		result2 error
	}
	updateAppReturnsOnCall map[int]struct {
		result1 cfclient.UpdateResponse
		result2 error
	}
	UpdateV3AppStub        func(string, cfclient.UpdateV3AppRequest) (*cfclient.V3App, error)
	updateV3AppMutex       sync.RWMutex
	updateV3AppArgsForCall []struct {
		arg1 string
		arg2 cfclient.UpdateV3AppRequest
	}
	updateV3AppReturns struct {
		result1 *cfclient.V3App
		result2 error
	}
	updateV3AppReturnsOnCall map[int]struct {
		result1 *cfclient.V3App
		result2 error
	}
	UploadAppBitsStub        func(io.Reader, string) error
	uploadAppBitsMutex       sync.RWMutex
	uploadAppBitsArgsForCall []struct {
		arg1 io.Reader
		arg2 string
	}
	uploadAppBitsReturns struct {
		result1 error
	}
	uploadAppBitsReturnsOnCall map[int]struct {
		result1 error
	}
	UploadDropletBitsStub        func(io.Reader, string) (string, error)
	uploadDropletBitsMutex       sync.RWMutex
	uploadDropletBitsArgsForCall []struct {
		arg1 io.Reader
		arg2 string
	}
	uploadDropletBitsReturns struct {
		result1 string
		result2 error
	}
	uploadDropletBitsReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeClient) AppByName(arg1 string, arg2 string, arg3 string) (cfclient.App, error) {
	fake.appByNameMutex.Lock()
	ret, specificReturn := fake.appByNameReturnsOnCall[len(fake.appByNameArgsForCall)]
	fake.appByNameArgsForCall = append(fake.appByNameArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.AppByNameStub
	fakeReturns := fake.appByNameReturns
	fake.recordInvocation("AppByName", []interface{}{arg1, arg2, arg3})
	fake.appByNameMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) AppByNameCallCount() int {
	fake.appByNameMutex.RLock()
	defer fake.appByNameMutex.RUnlock()
	return len(fake.appByNameArgsForCall)
}

func (fake *FakeClient) AppByNameCalls(stub func(string, string, string) (cfclient.App, error)) {
	fake.appByNameMutex.Lock()
	defer fake.appByNameMutex.Unlock()
	fake.AppByNameStub = stub
}

func (fake *FakeClient) AppByNameArgsForCall(i int) (string, string, string) {
	fake.appByNameMutex.RLock()
	defer fake.appByNameMutex.RUnlock()
	argsForCall := fake.appByNameArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) AppByNameReturns(result1 cfclient.App, result2 error) {
	fake.appByNameMutex.Lock()
	defer fake.appByNameMutex.Unlock()
	fake.AppByNameStub = nil
	fake.appByNameReturns = struct {
		result1 cfclient.App
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) AppByNameReturnsOnCall(i int, result1 cfclient.App, result2 error) {
	fake.appByNameMutex.Lock()
	defer fake.appByNameMutex.Unlock()
	fake.AppByNameStub = nil
	if fake.appByNameReturnsOnCall == nil {
		fake.appByNameReturnsOnCall = make(map[int]struct {
			result1 cfclient.App
			result2 error
		})
	}
	fake.appByNameReturnsOnCall[i] = struct {
		result1 cfclient.App
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) BindRoute(arg1 string, arg2 string) error {
	fake.bindRouteMutex.Lock()
	ret, specificReturn := fake.bindRouteReturnsOnCall[len(fake.bindRouteArgsForCall)]
	fake.bindRouteArgsForCall = append(fake.bindRouteArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.BindRouteStub
	fakeReturns := fake.bindRouteReturns
	fake.recordInvocation("BindRoute", []interface{}{arg1, arg2})
	fake.bindRouteMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) BindRouteCallCount() int {
	fake.bindRouteMutex.RLock()
	defer fake.bindRouteMutex.RUnlock()
	return len(fake.bindRouteArgsForCall)
}

func (fake *FakeClient) BindRouteCalls(stub func(string, string) error) {
	fake.bindRouteMutex.Lock()
	defer fake.bindRouteMutex.Unlock()
	fake.BindRouteStub = stub
}

func (fake *FakeClient) BindRouteArgsForCall(i int) (string, string) {
	fake.bindRouteMutex.RLock()
	defer fake.bindRouteMutex.RUnlock()
	argsForCall := fake.bindRouteArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) BindRouteReturns(result1 error) {
	fake.bindRouteMutex.Lock()
	defer fake.bindRouteMutex.Unlock()
	fake.BindRouteStub = nil
	fake.bindRouteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) BindRouteReturnsOnCall(i int, result1 error) {
	fake.bindRouteMutex.Lock()
	defer fake.bindRouteMutex.Unlock()
	fake.BindRouteStub = nil
	if fake.bindRouteReturnsOnCall == nil {
		fake.bindRouteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.bindRouteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) CreateApp(arg1 cfclient.AppCreateRequest) (cfclient.App, error) {
	fake.createAppMutex.Lock()
	ret, specificReturn := fake.createAppReturnsOnCall[len(fake.createAppArgsForCall)]
	fake.createAppArgsForCall = append(fake.createAppArgsForCall, struct {
		arg1 cfclient.AppCreateRequest
	}{arg1})
	stub := fake.CreateAppStub
	fakeReturns := fake.createAppReturns
	fake.recordInvocation("CreateApp", []interface{}{arg1})
	fake.createAppMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) CreateAppCallCount() int {
	fake.createAppMutex.RLock()
	defer fake.createAppMutex.RUnlock()
	return len(fake.createAppArgsForCall)
}

func (fake *FakeClient) CreateAppCalls(stub func(cfclient.AppCreateRequest) (cfclient.App, error)) {
	fake.createAppMutex.Lock()
	defer fake.createAppMutex.Unlock()
	fake.CreateAppStub = stub
}

func (fake *FakeClient) CreateAppArgsForCall(i int) cfclient.AppCreateRequest {
	fake.createAppMutex.RLock()
	defer fake.createAppMutex.RUnlock()
	argsForCall := fake.createAppArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) CreateAppReturns(result1 cfclient.App, result2 error) {
	fake.createAppMutex.Lock()
	defer fake.createAppMutex.Unlock()
	fake.CreateAppStub = nil
	fake.createAppReturns = struct {
		result1 cfclient.App
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CreateAppReturnsOnCall(i int, result1 cfclient.App, result2 error) {
	fake.createAppMutex.Lock()
	defer fake.createAppMutex.Unlock()
	fake.CreateAppStub = nil
	if fake.createAppReturnsOnCall == nil {
		fake.createAppReturnsOnCall = make(map[int]struct {
			result1 cfclient.App
			result2 error
		})
	}
	fake.createAppReturnsOnCall[i] = struct {
		result1 cfclient.App
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CreateOrg(arg1 cfclient.OrgRequest) (cfclient.Org, error) {
	fake.createOrgMutex.Lock()
	ret, specificReturn := fake.createOrgReturnsOnCall[len(fake.createOrgArgsForCall)]
	fake.createOrgArgsForCall = append(fake.createOrgArgsForCall, struct {
		arg1 cfclient.OrgRequest
	}{arg1})
	stub := fake.CreateOrgStub
	fakeReturns := fake.createOrgReturns
	fake.recordInvocation("CreateOrg", []interface{}{arg1})
	fake.createOrgMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) CreateOrgCallCount() int {
	fake.createOrgMutex.RLock()
	defer fake.createOrgMutex.RUnlock()
	return len(fake.createOrgArgsForCall)
}

func (fake *FakeClient) CreateOrgCalls(stub func(cfclient.OrgRequest) (cfclient.Org, error)) {
	fake.createOrgMutex.Lock()
	defer fake.createOrgMutex.Unlock()
	fake.CreateOrgStub = stub
}

func (fake *FakeClient) CreateOrgArgsForCall(i int) cfclient.OrgRequest {
	fake.createOrgMutex.RLock()
	defer fake.createOrgMutex.RUnlock()
	argsForCall := fake.createOrgArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) CreateOrgReturns(result1 cfclient.Org, result2 error) {
	fake.createOrgMutex.Lock()
	defer fake.createOrgMutex.Unlock()
	fake.CreateOrgStub = nil
	fake.createOrgReturns = struct {
		result1 cfclient.Org
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CreateOrgReturnsOnCall(i int, result1 cfclient.Org, result2 error) {
	fake.createOrgMutex.Lock()
	defer fake.createOrgMutex.Unlock()
	fake.CreateOrgStub = nil
	if fake.createOrgReturnsOnCall == nil {
		fake.createOrgReturnsOnCall = make(map[int]struct {
			result1 cfclient.Org
			result2 error
		})
	}
	fake.createOrgReturnsOnCall[i] = struct {
		result1 cfclient.Org
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CreateRoute(arg1 cfclient.RouteRequest) (cfclient.Route, error) {
	fake.createRouteMutex.Lock()
	ret, specificReturn := fake.createRouteReturnsOnCall[len(fake.createRouteArgsForCall)]
	fake.createRouteArgsForCall = append(fake.createRouteArgsForCall, struct {
		arg1 cfclient.RouteRequest
	}{arg1})
	stub := fake.CreateRouteStub
	fakeReturns := fake.createRouteReturns
	fake.recordInvocation("CreateRoute", []interface{}{arg1})
	fake.createRouteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) CreateRouteCallCount() int {
	fake.createRouteMutex.RLock()
	defer fake.createRouteMutex.RUnlock()
	return len(fake.createRouteArgsForCall)
}

func (fake *FakeClient) CreateRouteCalls(stub func(cfclient.RouteRequest) (cfclient.Route, error)) {
	fake.createRouteMutex.Lock()
	defer fake.createRouteMutex.Unlock()
	fake.CreateRouteStub = stub
}

func (fake *FakeClient) CreateRouteArgsForCall(i int) cfclient.RouteRequest {
	fake.createRouteMutex.RLock()
	defer fake.createRouteMutex.RUnlock()
	argsForCall := fake.createRouteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) CreateRouteReturns(result1 cfclient.Route, result2 error) {
	fake.createRouteMutex.Lock()
	defer fake.createRouteMutex.Unlock()
	fake.CreateRouteStub = nil
	fake.createRouteReturns = struct {
		result1 cfclient.Route
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CreateRouteReturnsOnCall(i int, result1 cfclient.Route, result2 error) {
	fake.createRouteMutex.Lock()
	defer fake.createRouteMutex.Unlock()
	fake.CreateRouteStub = nil
	if fake.createRouteReturnsOnCall == nil {
		fake.createRouteReturnsOnCall = make(map[int]struct {
			result1 cfclient.Route
			result2 error
		})
	}
	fake.createRouteReturnsOnCall[i] = struct {
		result1 cfclient.Route
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CreateServiceBinding(arg1 string, arg2 string) (*cfclient.ServiceBinding, error) {
	fake.createServiceBindingMutex.Lock()
	ret, specificReturn := fake.createServiceBindingReturnsOnCall[len(fake.createServiceBindingArgsForCall)]
	fake.createServiceBindingArgsForCall = append(fake.createServiceBindingArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.CreateServiceBindingStub
	fakeReturns := fake.createServiceBindingReturns
	fake.recordInvocation("CreateServiceBinding", []interface{}{arg1, arg2})
	fake.createServiceBindingMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) CreateServiceBindingCallCount() int {
	fake.createServiceBindingMutex.RLock()
	defer fake.createServiceBindingMutex.RUnlock()
	return len(fake.createServiceBindingArgsForCall)
}

func (fake *FakeClient) CreateServiceBindingCalls(stub func(string, string) (*cfclient.ServiceBinding, error)) {
	fake.createServiceBindingMutex.Lock()
	defer fake.createServiceBindingMutex.Unlock()
	fake.CreateServiceBindingStub = stub
}

func (fake *FakeClient) CreateServiceBindingArgsForCall(i int) (string, string) {
	fake.createServiceBindingMutex.RLock()
	defer fake.createServiceBindingMutex.RUnlock()
	argsForCall := fake.createServiceBindingArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) CreateServiceBindingReturns(result1 *cfclient.ServiceBinding, result2 error) {
	fake.createServiceBindingMutex.Lock()
	defer fake.createServiceBindingMutex.Unlock()
	fake.CreateServiceBindingStub = nil
	fake.createServiceBindingReturns = struct {
		result1 *cfclient.ServiceBinding
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CreateServiceBindingReturnsOnCall(i int, result1 *cfclient.ServiceBinding, result2 error) {
	fake.createServiceBindingMutex.Lock()
	defer fake.createServiceBindingMutex.Unlock()
	fake.CreateServiceBindingStub = nil
	if fake.createServiceBindingReturnsOnCall == nil {
		fake.createServiceBindingReturnsOnCall = make(map[int]struct {
			result1 *cfclient.ServiceBinding
			result2 error
		})
	}
	fake.createServiceBindingReturnsOnCall[i] = struct {
		result1 *cfclient.ServiceBinding
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CreateSpace(arg1 cfclient.SpaceRequest) (cfclient.Space, error) {
	fake.createSpaceMutex.Lock()
	ret, specificReturn := fake.createSpaceReturnsOnCall[len(fake.createSpaceArgsForCall)]
	fake.createSpaceArgsForCall = append(fake.createSpaceArgsForCall, struct {
		arg1 cfclient.SpaceRequest
	}{arg1})
	stub := fake.CreateSpaceStub
	fakeReturns := fake.createSpaceReturns
	fake.recordInvocation("CreateSpace", []interface{}{arg1})
	fake.createSpaceMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) CreateSpaceCallCount() int {
	fake.createSpaceMutex.RLock()
	defer fake.createSpaceMutex.RUnlock()
	return len(fake.createSpaceArgsForCall)
}

func (fake *FakeClient) CreateSpaceCalls(stub func(cfclient.SpaceRequest) (cfclient.Space, error)) {
	fake.createSpaceMutex.Lock()
	defer fake.createSpaceMutex.Unlock()
	fake.CreateSpaceStub = stub
}

func (fake *FakeClient) CreateSpaceArgsForCall(i int) cfclient.SpaceRequest {
	fake.createSpaceMutex.RLock()
	defer fake.createSpaceMutex.RUnlock()
	argsForCall := fake.createSpaceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) CreateSpaceReturns(result1 cfclient.Space, result2 error) {
	fake.createSpaceMutex.Lock()
	defer fake.createSpaceMutex.Unlock()
	fake.CreateSpaceStub = nil
	fake.createSpaceReturns = struct {
		result1 cfclient.Space
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CreateSpaceReturnsOnCall(i int, result1 cfclient.Space, result2 error) {
	fake.createSpaceMutex.Lock()
	defer fake.createSpaceMutex.Unlock()
	fake.CreateSpaceStub = nil
	if fake.createSpaceReturnsOnCall == nil {
		fake.createSpaceReturnsOnCall = make(map[int]struct {
			result1 cfclient.Space
			result2 error
		})
	}
	fake.createSpaceReturnsOnCall[i] = struct {
		result1 cfclient.Space
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) DeleteApp(arg1 string) error {
	fake.deleteAppMutex.Lock()
	ret, specificReturn := fake.deleteAppReturnsOnCall[len(fake.deleteAppArgsForCall)]
	fake.deleteAppArgsForCall = append(fake.deleteAppArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.DeleteAppStub
	fakeReturns := fake.deleteAppReturns
	fake.recordInvocation("DeleteApp", []interface{}{arg1})
	fake.deleteAppMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) DeleteAppCallCount() int {
	fake.deleteAppMutex.RLock()
	defer fake.deleteAppMutex.RUnlock()
	return len(fake.deleteAppArgsForCall)
}

func (fake *FakeClient) DeleteAppCalls(stub func(string) error) {
	fake.deleteAppMutex.Lock()
	defer fake.deleteAppMutex.Unlock()
	fake.DeleteAppStub = stub
}

func (fake *FakeClient) DeleteAppArgsForCall(i int) string {
	fake.deleteAppMutex.RLock()
	defer fake.deleteAppMutex.RUnlock()
	argsForCall := fake.deleteAppArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) DeleteAppReturns(result1 error) {
	fake.deleteAppMutex.Lock()
	defer fake.deleteAppMutex.Unlock()
	fake.DeleteAppStub = nil
	fake.deleteAppReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) DeleteAppReturnsOnCall(i int, result1 error) {
	fake.deleteAppMutex.Lock()
	defer fake.deleteAppMutex.Unlock()
	fake.DeleteAppStub = nil
	if fake.deleteAppReturnsOnCall == nil {
		fake.deleteAppReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteAppReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) DeleteOrg(arg1 string, arg2 bool, arg3 bool) error {
	fake.deleteOrgMutex.Lock()
	ret, specificReturn := fake.deleteOrgReturnsOnCall[len(fake.deleteOrgArgsForCall)]
	fake.deleteOrgArgsForCall = append(fake.deleteOrgArgsForCall, struct {
		arg1 string
		arg2 bool
		arg3 bool
	}{arg1, arg2, arg3})
	stub := fake.DeleteOrgStub
	fakeReturns := fake.deleteOrgReturns
	fake.recordInvocation("DeleteOrg", []interface{}{arg1, arg2, arg3})
	fake.deleteOrgMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) DeleteOrgCallCount() int {
	fake.deleteOrgMutex.RLock()
	defer fake.deleteOrgMutex.RUnlock()
	return len(fake.deleteOrgArgsForCall)
}

func (fake *FakeClient) DeleteOrgCalls(stub func(string, bool, bool) error) {
	fake.deleteOrgMutex.Lock()
	defer fake.deleteOrgMutex.Unlock()
	fake.DeleteOrgStub = stub
}

func (fake *FakeClient) DeleteOrgArgsForCall(i int) (string, bool, bool) {
	fake.deleteOrgMutex.RLock()
	defer fake.deleteOrgMutex.RUnlock()
	argsForCall := fake.deleteOrgArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) DeleteOrgReturns(result1 error) {
	fake.deleteOrgMutex.Lock()
	defer fake.deleteOrgMutex.Unlock()
	fake.DeleteOrgStub = nil
	fake.deleteOrgReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) DeleteOrgReturnsOnCall(i int, result1 error) {
	fake.deleteOrgMutex.Lock()
	defer fake.deleteOrgMutex.Unlock()
	fake.DeleteOrgStub = nil
	if fake.deleteOrgReturnsOnCall == nil {
		fake.deleteOrgReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteOrgReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) Do(arg1 *http.Request) (*http.Response, error) {
	fake.doMutex.Lock()
	ret, specificReturn := fake.doReturnsOnCall[len(fake.doArgsForCall)]
	fake.doArgsForCall = append(fake.doArgsForCall, struct {
		arg1 *http.Request
	}{arg1})
	stub := fake.DoStub
	fakeReturns := fake.doReturns
	fake.recordInvocation("Do", []interface{}{arg1})
	fake.doMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) DoCallCount() int {
	fake.doMutex.RLock()
	defer fake.doMutex.RUnlock()
	return len(fake.doArgsForCall)
}

func (fake *FakeClient) DoCalls(stub func(*http.Request) (*http.Response, error)) {
	fake.doMutex.Lock()
	defer fake.doMutex.Unlock()
	fake.DoStub = stub
}

func (fake *FakeClient) DoArgsForCall(i int) *http.Request {
	fake.doMutex.RLock()
	defer fake.doMutex.RUnlock()
	argsForCall := fake.doArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) DoReturns(result1 *http.Response, result2 error) {
	fake.doMutex.Lock()
	defer fake.doMutex.Unlock()
	fake.DoStub = nil
	fake.doReturns = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) DoReturnsOnCall(i int, result1 *http.Response, result2 error) {
	fake.doMutex.Lock()
	defer fake.doMutex.Unlock()
	fake.DoStub = nil
	if fake.doReturnsOnCall == nil {
		fake.doReturnsOnCall = make(map[int]struct {
			result1 *http.Response
			result2 error
		})
	}
	fake.doReturnsOnCall[i] = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) DoRequest(arg1 *cfclient.Request) (*http.Response, error) {
	fake.doRequestMutex.Lock()
	ret, specificReturn := fake.doRequestReturnsOnCall[len(fake.doRequestArgsForCall)]
	fake.doRequestArgsForCall = append(fake.doRequestArgsForCall, struct {
		arg1 *cfclient.Request
	}{arg1})
	stub := fake.DoRequestStub
	fakeReturns := fake.doRequestReturns
	fake.recordInvocation("DoRequest", []interface{}{arg1})
	fake.doRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) DoRequestCallCount() int {
	fake.doRequestMutex.RLock()
	defer fake.doRequestMutex.RUnlock()
	return len(fake.doRequestArgsForCall)
}

func (fake *FakeClient) DoRequestCalls(stub func(*cfclient.Request) (*http.Response, error)) {
	fake.doRequestMutex.Lock()
	defer fake.doRequestMutex.Unlock()
	fake.DoRequestStub = stub
}

func (fake *FakeClient) DoRequestArgsForCall(i int) *cfclient.Request {
	fake.doRequestMutex.RLock()
	defer fake.doRequestMutex.RUnlock()
	argsForCall := fake.doRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) DoRequestReturns(result1 *http.Response, result2 error) {
	fake.doRequestMutex.Lock()
	defer fake.doRequestMutex.Unlock()
	fake.DoRequestStub = nil
	fake.doRequestReturns = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) DoRequestReturnsOnCall(i int, result1 *http.Response, result2 error) {
	fake.doRequestMutex.Lock()
	defer fake.doRequestMutex.Unlock()
	fake.DoRequestStub = nil
	if fake.doRequestReturnsOnCall == nil {
		fake.doRequestReturnsOnCall = make(map[int]struct {
			result1 *http.Response
			result2 error
		})
	}
	fake.doRequestReturnsOnCall[i] = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) DoWithRetry(arg1 func() error) error {
	fake.doWithRetryMutex.Lock()
	ret, specificReturn := fake.doWithRetryReturnsOnCall[len(fake.doWithRetryArgsForCall)]
	fake.doWithRetryArgsForCall = append(fake.doWithRetryArgsForCall, struct {
		arg1 func() error
	}{arg1})
	stub := fake.DoWithRetryStub
	fakeReturns := fake.doWithRetryReturns
	fake.recordInvocation("DoWithRetry", []interface{}{arg1})
	fake.doWithRetryMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) DoWithRetryCallCount() int {
	fake.doWithRetryMutex.RLock()
	defer fake.doWithRetryMutex.RUnlock()
	return len(fake.doWithRetryArgsForCall)
}

func (fake *FakeClient) DoWithRetryCalls(stub func(func() error) error) {
	fake.doWithRetryMutex.Lock()
	defer fake.doWithRetryMutex.Unlock()
	fake.DoWithRetryStub = stub
}

func (fake *FakeClient) DoWithRetryArgsForCall(i int) func() error {
	fake.doWithRetryMutex.RLock()
	defer fake.doWithRetryMutex.RUnlock()
	argsForCall := fake.doWithRetryArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) DoWithRetryReturns(result1 error) {
	fake.doWithRetryMutex.Lock()
	defer fake.doWithRetryMutex.Unlock()
	fake.DoWithRetryStub = nil
	fake.doWithRetryReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) DoWithRetryReturnsOnCall(i int, result1 error) {
	fake.doWithRetryMutex.Lock()
	defer fake.doWithRetryMutex.Unlock()
	fake.DoWithRetryStub = nil
	if fake.doWithRetryReturnsOnCall == nil {
		fake.doWithRetryReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.doWithRetryReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) Get(arg1 string) ([]byte, error) {
	fake.getMutex.Lock()
	ret, specificReturn := fake.getReturnsOnCall[len(fake.getArgsForCall)]
	fake.getArgsForCall = append(fake.getArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetStub
	fakeReturns := fake.getReturns
	fake.recordInvocation("Get", []interface{}{arg1})
	fake.getMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) GetCallCount() int {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	return len(fake.getArgsForCall)
}

func (fake *FakeClient) GetCalls(stub func(string) ([]byte, error)) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = stub
}

func (fake *FakeClient) GetArgsForCall(i int) string {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	argsForCall := fake.getArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) GetReturns(result1 []byte, result2 error) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = nil
	fake.getReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = nil
	if fake.getReturnsOnCall == nil {
		fake.getReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.getReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetAppByGuidNoInlineCall(arg1 string) (cfclient.App, error) {
	fake.getAppByGuidNoInlineCallMutex.Lock()
	ret, specificReturn := fake.getAppByGuidNoInlineCallReturnsOnCall[len(fake.getAppByGuidNoInlineCallArgsForCall)]
	fake.getAppByGuidNoInlineCallArgsForCall = append(fake.getAppByGuidNoInlineCallArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetAppByGuidNoInlineCallStub
	fakeReturns := fake.getAppByGuidNoInlineCallReturns
	fake.recordInvocation("GetAppByGuidNoInlineCall", []interface{}{arg1})
	fake.getAppByGuidNoInlineCallMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) GetAppByGuidNoInlineCallCallCount() int {
	fake.getAppByGuidNoInlineCallMutex.RLock()
	defer fake.getAppByGuidNoInlineCallMutex.RUnlock()
	return len(fake.getAppByGuidNoInlineCallArgsForCall)
}

func (fake *FakeClient) GetAppByGuidNoInlineCallCalls(stub func(string) (cfclient.App, error)) {
	fake.getAppByGuidNoInlineCallMutex.Lock()
	defer fake.getAppByGuidNoInlineCallMutex.Unlock()
	fake.GetAppByGuidNoInlineCallStub = stub
}

func (fake *FakeClient) GetAppByGuidNoInlineCallArgsForCall(i int) string {
	fake.getAppByGuidNoInlineCallMutex.RLock()
	defer fake.getAppByGuidNoInlineCallMutex.RUnlock()
	argsForCall := fake.getAppByGuidNoInlineCallArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) GetAppByGuidNoInlineCallReturns(result1 cfclient.App, result2 error) {
	fake.getAppByGuidNoInlineCallMutex.Lock()
	defer fake.getAppByGuidNoInlineCallMutex.Unlock()
	fake.GetAppByGuidNoInlineCallStub = nil
	fake.getAppByGuidNoInlineCallReturns = struct {
		result1 cfclient.App
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetAppByGuidNoInlineCallReturnsOnCall(i int, result1 cfclient.App, result2 error) {
	fake.getAppByGuidNoInlineCallMutex.Lock()
	defer fake.getAppByGuidNoInlineCallMutex.Unlock()
	fake.GetAppByGuidNoInlineCallStub = nil
	if fake.getAppByGuidNoInlineCallReturnsOnCall == nil {
		fake.getAppByGuidNoInlineCallReturnsOnCall = make(map[int]struct {
			result1 cfclient.App
			result2 error
		})
	}
	fake.getAppByGuidNoInlineCallReturnsOnCall[i] = struct {
		result1 cfclient.App
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetClientConfig() *cfclient.Config {
	fake.getClientConfigMutex.Lock()
	ret, specificReturn := fake.getClientConfigReturnsOnCall[len(fake.getClientConfigArgsForCall)]
	fake.getClientConfigArgsForCall = append(fake.getClientConfigArgsForCall, struct {
	}{})
	stub := fake.GetClientConfigStub
	fakeReturns := fake.getClientConfigReturns
	fake.recordInvocation("GetClientConfig", []interface{}{})
	fake.getClientConfigMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) GetClientConfigCallCount() int {
	fake.getClientConfigMutex.RLock()
	defer fake.getClientConfigMutex.RUnlock()
	return len(fake.getClientConfigArgsForCall)
}

func (fake *FakeClient) GetClientConfigCalls(stub func() *cfclient.Config) {
	fake.getClientConfigMutex.Lock()
	defer fake.getClientConfigMutex.Unlock()
	fake.GetClientConfigStub = stub
}

func (fake *FakeClient) GetClientConfigReturns(result1 *cfclient.Config) {
	fake.getClientConfigMutex.Lock()
	defer fake.getClientConfigMutex.Unlock()
	fake.GetClientConfigStub = nil
	fake.getClientConfigReturns = struct {
		result1 *cfclient.Config
	}{result1}
}

func (fake *FakeClient) GetClientConfigReturnsOnCall(i int, result1 *cfclient.Config) {
	fake.getClientConfigMutex.Lock()
	defer fake.getClientConfigMutex.Unlock()
	fake.GetClientConfigStub = nil
	if fake.getClientConfigReturnsOnCall == nil {
		fake.getClientConfigReturnsOnCall = make(map[int]struct {
			result1 *cfclient.Config
		})
	}
	fake.getClientConfigReturnsOnCall[i] = struct {
		result1 *cfclient.Config
	}{result1}
}

func (fake *FakeClient) GetDomainByName(arg1 string) (cfclient.Domain, error) {
	fake.getDomainByNameMutex.Lock()
	ret, specificReturn := fake.getDomainByNameReturnsOnCall[len(fake.getDomainByNameArgsForCall)]
	fake.getDomainByNameArgsForCall = append(fake.getDomainByNameArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetDomainByNameStub
	fakeReturns := fake.getDomainByNameReturns
	fake.recordInvocation("GetDomainByName", []interface{}{arg1})
	fake.getDomainByNameMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) GetDomainByNameCallCount() int {
	fake.getDomainByNameMutex.RLock()
	defer fake.getDomainByNameMutex.RUnlock()
	return len(fake.getDomainByNameArgsForCall)
}

func (fake *FakeClient) GetDomainByNameCalls(stub func(string) (cfclient.Domain, error)) {
	fake.getDomainByNameMutex.Lock()
	defer fake.getDomainByNameMutex.Unlock()
	fake.GetDomainByNameStub = stub
}

func (fake *FakeClient) GetDomainByNameArgsForCall(i int) string {
	fake.getDomainByNameMutex.RLock()
	defer fake.getDomainByNameMutex.RUnlock()
	argsForCall := fake.getDomainByNameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) GetDomainByNameReturns(result1 cfclient.Domain, result2 error) {
	fake.getDomainByNameMutex.Lock()
	defer fake.getDomainByNameMutex.Unlock()
	fake.GetDomainByNameStub = nil
	fake.getDomainByNameReturns = struct {
		result1 cfclient.Domain
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetDomainByNameReturnsOnCall(i int, result1 cfclient.Domain, result2 error) {
	fake.getDomainByNameMutex.Lock()
	defer fake.getDomainByNameMutex.Unlock()
	fake.GetDomainByNameStub = nil
	if fake.getDomainByNameReturnsOnCall == nil {
		fake.getDomainByNameReturnsOnCall = make(map[int]struct {
			result1 cfclient.Domain
			result2 error
		})
	}
	fake.getDomainByNameReturnsOnCall[i] = struct {
		result1 cfclient.Domain
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetOrgByGuid(arg1 string) (cfclient.Org, error) {
	fake.getOrgByGuidMutex.Lock()
	ret, specificReturn := fake.getOrgByGuidReturnsOnCall[len(fake.getOrgByGuidArgsForCall)]
	fake.getOrgByGuidArgsForCall = append(fake.getOrgByGuidArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetOrgByGuidStub
	fakeReturns := fake.getOrgByGuidReturns
	fake.recordInvocation("GetOrgByGuid", []interface{}{arg1})
	fake.getOrgByGuidMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) GetOrgByGuidCallCount() int {
	fake.getOrgByGuidMutex.RLock()
	defer fake.getOrgByGuidMutex.RUnlock()
	return len(fake.getOrgByGuidArgsForCall)
}

func (fake *FakeClient) GetOrgByGuidCalls(stub func(string) (cfclient.Org, error)) {
	fake.getOrgByGuidMutex.Lock()
	defer fake.getOrgByGuidMutex.Unlock()
	fake.GetOrgByGuidStub = stub
}

func (fake *FakeClient) GetOrgByGuidArgsForCall(i int) string {
	fake.getOrgByGuidMutex.RLock()
	defer fake.getOrgByGuidMutex.RUnlock()
	argsForCall := fake.getOrgByGuidArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) GetOrgByGuidReturns(result1 cfclient.Org, result2 error) {
	fake.getOrgByGuidMutex.Lock()
	defer fake.getOrgByGuidMutex.Unlock()
	fake.GetOrgByGuidStub = nil
	fake.getOrgByGuidReturns = struct {
		result1 cfclient.Org
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetOrgByGuidReturnsOnCall(i int, result1 cfclient.Org, result2 error) {
	fake.getOrgByGuidMutex.Lock()
	defer fake.getOrgByGuidMutex.Unlock()
	fake.GetOrgByGuidStub = nil
	if fake.getOrgByGuidReturnsOnCall == nil {
		fake.getOrgByGuidReturnsOnCall = make(map[int]struct {
			result1 cfclient.Org
			result2 error
		})
	}
	fake.getOrgByGuidReturnsOnCall[i] = struct {
		result1 cfclient.Org
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetOrgByName(arg1 string) (cfclient.Org, error) {
	fake.getOrgByNameMutex.Lock()
	ret, specificReturn := fake.getOrgByNameReturnsOnCall[len(fake.getOrgByNameArgsForCall)]
	fake.getOrgByNameArgsForCall = append(fake.getOrgByNameArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetOrgByNameStub
	fakeReturns := fake.getOrgByNameReturns
	fake.recordInvocation("GetOrgByName", []interface{}{arg1})
	fake.getOrgByNameMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) GetOrgByNameCallCount() int {
	fake.getOrgByNameMutex.RLock()
	defer fake.getOrgByNameMutex.RUnlock()
	return len(fake.getOrgByNameArgsForCall)
}

func (fake *FakeClient) GetOrgByNameCalls(stub func(string) (cfclient.Org, error)) {
	fake.getOrgByNameMutex.Lock()
	defer fake.getOrgByNameMutex.Unlock()
	fake.GetOrgByNameStub = stub
}

func (fake *FakeClient) GetOrgByNameArgsForCall(i int) string {
	fake.getOrgByNameMutex.RLock()
	defer fake.getOrgByNameMutex.RUnlock()
	argsForCall := fake.getOrgByNameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) GetOrgByNameReturns(result1 cfclient.Org, result2 error) {
	fake.getOrgByNameMutex.Lock()
	defer fake.getOrgByNameMutex.Unlock()
	fake.GetOrgByNameStub = nil
	fake.getOrgByNameReturns = struct {
		result1 cfclient.Org
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetOrgByNameReturnsOnCall(i int, result1 cfclient.Org, result2 error) {
	fake.getOrgByNameMutex.Lock()
	defer fake.getOrgByNameMutex.Unlock()
	fake.GetOrgByNameStub = nil
	if fake.getOrgByNameReturnsOnCall == nil {
		fake.getOrgByNameReturnsOnCall = make(map[int]struct {
			result1 cfclient.Org
			result2 error
		})
	}
	fake.getOrgByNameReturnsOnCall[i] = struct {
		result1 cfclient.Org
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetOrgQuotaByName(arg1 string) (cfclient.OrgQuota, error) {
	fake.getOrgQuotaByNameMutex.Lock()
	ret, specificReturn := fake.getOrgQuotaByNameReturnsOnCall[len(fake.getOrgQuotaByNameArgsForCall)]
	fake.getOrgQuotaByNameArgsForCall = append(fake.getOrgQuotaByNameArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetOrgQuotaByNameStub
	fakeReturns := fake.getOrgQuotaByNameReturns
	fake.recordInvocation("GetOrgQuotaByName", []interface{}{arg1})
	fake.getOrgQuotaByNameMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) GetOrgQuotaByNameCallCount() int {
	fake.getOrgQuotaByNameMutex.RLock()
	defer fake.getOrgQuotaByNameMutex.RUnlock()
	return len(fake.getOrgQuotaByNameArgsForCall)
}

func (fake *FakeClient) GetOrgQuotaByNameCalls(stub func(string) (cfclient.OrgQuota, error)) {
	fake.getOrgQuotaByNameMutex.Lock()
	defer fake.getOrgQuotaByNameMutex.Unlock()
	fake.GetOrgQuotaByNameStub = stub
}

func (fake *FakeClient) GetOrgQuotaByNameArgsForCall(i int) string {
	fake.getOrgQuotaByNameMutex.RLock()
	defer fake.getOrgQuotaByNameMutex.RUnlock()
	argsForCall := fake.getOrgQuotaByNameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) GetOrgQuotaByNameReturns(result1 cfclient.OrgQuota, result2 error) {
	fake.getOrgQuotaByNameMutex.Lock()
	defer fake.getOrgQuotaByNameMutex.Unlock()
	fake.GetOrgQuotaByNameStub = nil
	fake.getOrgQuotaByNameReturns = struct {
		result1 cfclient.OrgQuota
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetOrgQuotaByNameReturnsOnCall(i int, result1 cfclient.OrgQuota, result2 error) {
	fake.getOrgQuotaByNameMutex.Lock()
	defer fake.getOrgQuotaByNameMutex.Unlock()
	fake.GetOrgQuotaByNameStub = nil
	if fake.getOrgQuotaByNameReturnsOnCall == nil {
		fake.getOrgQuotaByNameReturnsOnCall = make(map[int]struct {
			result1 cfclient.OrgQuota
			result2 error
		})
	}
	fake.getOrgQuotaByNameReturnsOnCall[i] = struct {
		result1 cfclient.OrgQuota
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetSharedDomainByName(arg1 string) (cfclient.SharedDomain, error) {
	fake.getSharedDomainByNameMutex.Lock()
	ret, specificReturn := fake.getSharedDomainByNameReturnsOnCall[len(fake.getSharedDomainByNameArgsForCall)]
	fake.getSharedDomainByNameArgsForCall = append(fake.getSharedDomainByNameArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetSharedDomainByNameStub
	fakeReturns := fake.getSharedDomainByNameReturns
	fake.recordInvocation("GetSharedDomainByName", []interface{}{arg1})
	fake.getSharedDomainByNameMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) GetSharedDomainByNameCallCount() int {
	fake.getSharedDomainByNameMutex.RLock()
	defer fake.getSharedDomainByNameMutex.RUnlock()
	return len(fake.getSharedDomainByNameArgsForCall)
}

func (fake *FakeClient) GetSharedDomainByNameCalls(stub func(string) (cfclient.SharedDomain, error)) {
	fake.getSharedDomainByNameMutex.Lock()
	defer fake.getSharedDomainByNameMutex.Unlock()
	fake.GetSharedDomainByNameStub = stub
}

func (fake *FakeClient) GetSharedDomainByNameArgsForCall(i int) string {
	fake.getSharedDomainByNameMutex.RLock()
	defer fake.getSharedDomainByNameMutex.RUnlock()
	argsForCall := fake.getSharedDomainByNameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) GetSharedDomainByNameReturns(result1 cfclient.SharedDomain, result2 error) {
	fake.getSharedDomainByNameMutex.Lock()
	defer fake.getSharedDomainByNameMutex.Unlock()
	fake.GetSharedDomainByNameStub = nil
	fake.getSharedDomainByNameReturns = struct {
		result1 cfclient.SharedDomain
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetSharedDomainByNameReturnsOnCall(i int, result1 cfclient.SharedDomain, result2 error) {
	fake.getSharedDomainByNameMutex.Lock()
	defer fake.getSharedDomainByNameMutex.Unlock()
	fake.GetSharedDomainByNameStub = nil
	if fake.getSharedDomainByNameReturnsOnCall == nil {
		fake.getSharedDomainByNameReturnsOnCall = make(map[int]struct {
			result1 cfclient.SharedDomain
			result2 error
		})
	}
	fake.getSharedDomainByNameReturnsOnCall[i] = struct {
		result1 cfclient.SharedDomain
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetSpaceByGuid(arg1 string) (cfclient.Space, error) {
	fake.getSpaceByGuidMutex.Lock()
	ret, specificReturn := fake.getSpaceByGuidReturnsOnCall[len(fake.getSpaceByGuidArgsForCall)]
	fake.getSpaceByGuidArgsForCall = append(fake.getSpaceByGuidArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetSpaceByGuidStub
	fakeReturns := fake.getSpaceByGuidReturns
	fake.recordInvocation("GetSpaceByGuid", []interface{}{arg1})
	fake.getSpaceByGuidMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) GetSpaceByGuidCallCount() int {
	fake.getSpaceByGuidMutex.RLock()
	defer fake.getSpaceByGuidMutex.RUnlock()
	return len(fake.getSpaceByGuidArgsForCall)
}

func (fake *FakeClient) GetSpaceByGuidCalls(stub func(string) (cfclient.Space, error)) {
	fake.getSpaceByGuidMutex.Lock()
	defer fake.getSpaceByGuidMutex.Unlock()
	fake.GetSpaceByGuidStub = stub
}

func (fake *FakeClient) GetSpaceByGuidArgsForCall(i int) string {
	fake.getSpaceByGuidMutex.RLock()
	defer fake.getSpaceByGuidMutex.RUnlock()
	argsForCall := fake.getSpaceByGuidArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) GetSpaceByGuidReturns(result1 cfclient.Space, result2 error) {
	fake.getSpaceByGuidMutex.Lock()
	defer fake.getSpaceByGuidMutex.Unlock()
	fake.GetSpaceByGuidStub = nil
	fake.getSpaceByGuidReturns = struct {
		result1 cfclient.Space
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetSpaceByGuidReturnsOnCall(i int, result1 cfclient.Space, result2 error) {
	fake.getSpaceByGuidMutex.Lock()
	defer fake.getSpaceByGuidMutex.Unlock()
	fake.GetSpaceByGuidStub = nil
	if fake.getSpaceByGuidReturnsOnCall == nil {
		fake.getSpaceByGuidReturnsOnCall = make(map[int]struct {
			result1 cfclient.Space
			result2 error
		})
	}
	fake.getSpaceByGuidReturnsOnCall[i] = struct {
		result1 cfclient.Space
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetSpaceByName(arg1 string, arg2 string) (cfclient.Space, error) {
	fake.getSpaceByNameMutex.Lock()
	ret, specificReturn := fake.getSpaceByNameReturnsOnCall[len(fake.getSpaceByNameArgsForCall)]
	fake.getSpaceByNameArgsForCall = append(fake.getSpaceByNameArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.GetSpaceByNameStub
	fakeReturns := fake.getSpaceByNameReturns
	fake.recordInvocation("GetSpaceByName", []interface{}{arg1, arg2})
	fake.getSpaceByNameMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) GetSpaceByNameCallCount() int {
	fake.getSpaceByNameMutex.RLock()
	defer fake.getSpaceByNameMutex.RUnlock()
	return len(fake.getSpaceByNameArgsForCall)
}

func (fake *FakeClient) GetSpaceByNameCalls(stub func(string, string) (cfclient.Space, error)) {
	fake.getSpaceByNameMutex.Lock()
	defer fake.getSpaceByNameMutex.Unlock()
	fake.GetSpaceByNameStub = stub
}

func (fake *FakeClient) GetSpaceByNameArgsForCall(i int) (string, string) {
	fake.getSpaceByNameMutex.RLock()
	defer fake.getSpaceByNameMutex.RUnlock()
	argsForCall := fake.getSpaceByNameArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) GetSpaceByNameReturns(result1 cfclient.Space, result2 error) {
	fake.getSpaceByNameMutex.Lock()
	defer fake.getSpaceByNameMutex.Unlock()
	fake.GetSpaceByNameStub = nil
	fake.getSpaceByNameReturns = struct {
		result1 cfclient.Space
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetSpaceByNameReturnsOnCall(i int, result1 cfclient.Space, result2 error) {
	fake.getSpaceByNameMutex.Lock()
	defer fake.getSpaceByNameMutex.Unlock()
	fake.GetSpaceByNameStub = nil
	if fake.getSpaceByNameReturnsOnCall == nil {
		fake.getSpaceByNameReturnsOnCall = make(map[int]struct {
			result1 cfclient.Space
			result2 error
		})
	}
	fake.getSpaceByNameReturnsOnCall[i] = struct {
		result1 cfclient.Space
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetStackByGuid(arg1 string) (cfclient.Stack, error) {
	fake.getStackByGuidMutex.Lock()
	ret, specificReturn := fake.getStackByGuidReturnsOnCall[len(fake.getStackByGuidArgsForCall)]
	fake.getStackByGuidArgsForCall = append(fake.getStackByGuidArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetStackByGuidStub
	fakeReturns := fake.getStackByGuidReturns
	fake.recordInvocation("GetStackByGuid", []interface{}{arg1})
	fake.getStackByGuidMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) GetStackByGuidCallCount() int {
	fake.getStackByGuidMutex.RLock()
	defer fake.getStackByGuidMutex.RUnlock()
	return len(fake.getStackByGuidArgsForCall)
}

func (fake *FakeClient) GetStackByGuidCalls(stub func(string) (cfclient.Stack, error)) {
	fake.getStackByGuidMutex.Lock()
	defer fake.getStackByGuidMutex.Unlock()
	fake.GetStackByGuidStub = stub
}

func (fake *FakeClient) GetStackByGuidArgsForCall(i int) string {
	fake.getStackByGuidMutex.RLock()
	defer fake.getStackByGuidMutex.RUnlock()
	argsForCall := fake.getStackByGuidArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) GetStackByGuidReturns(result1 cfclient.Stack, result2 error) {
	fake.getStackByGuidMutex.Lock()
	defer fake.getStackByGuidMutex.Unlock()
	fake.GetStackByGuidStub = nil
	fake.getStackByGuidReturns = struct {
		result1 cfclient.Stack
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetStackByGuidReturnsOnCall(i int, result1 cfclient.Stack, result2 error) {
	fake.getStackByGuidMutex.Lock()
	defer fake.getStackByGuidMutex.Unlock()
	fake.GetStackByGuidStub = nil
	if fake.getStackByGuidReturnsOnCall == nil {
		fake.getStackByGuidReturnsOnCall = make(map[int]struct {
			result1 cfclient.Stack
			result2 error
		})
	}
	fake.getStackByGuidReturnsOnCall[i] = struct {
		result1 cfclient.Stack
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) HTTPClient() *http.Client {
	fake.hTTPClientMutex.Lock()
	ret, specificReturn := fake.hTTPClientReturnsOnCall[len(fake.hTTPClientArgsForCall)]
	fake.hTTPClientArgsForCall = append(fake.hTTPClientArgsForCall, struct {
	}{})
	stub := fake.HTTPClientStub
	fakeReturns := fake.hTTPClientReturns
	fake.recordInvocation("HTTPClient", []interface{}{})
	fake.hTTPClientMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) HTTPClientCallCount() int {
	fake.hTTPClientMutex.RLock()
	defer fake.hTTPClientMutex.RUnlock()
	return len(fake.hTTPClientArgsForCall)
}

func (fake *FakeClient) HTTPClientCalls(stub func() *http.Client) {
	fake.hTTPClientMutex.Lock()
	defer fake.hTTPClientMutex.Unlock()
	fake.HTTPClientStub = stub
}

func (fake *FakeClient) HTTPClientReturns(result1 *http.Client) {
	fake.hTTPClientMutex.Lock()
	defer fake.hTTPClientMutex.Unlock()
	fake.HTTPClientStub = nil
	fake.hTTPClientReturns = struct {
		result1 *http.Client
	}{result1}
}

func (fake *FakeClient) HTTPClientReturnsOnCall(i int, result1 *http.Client) {
	fake.hTTPClientMutex.Lock()
	defer fake.hTTPClientMutex.Unlock()
	fake.HTTPClientStub = nil
	if fake.hTTPClientReturnsOnCall == nil {
		fake.hTTPClientReturnsOnCall = make(map[int]struct {
			result1 *http.Client
		})
	}
	fake.hTTPClientReturnsOnCall[i] = struct {
		result1 *http.Client
	}{result1}
}

func (fake *FakeClient) ListAppsByQuery(arg1 url.Values) ([]cfclient.App, error) {
	fake.listAppsByQueryMutex.Lock()
	ret, specificReturn := fake.listAppsByQueryReturnsOnCall[len(fake.listAppsByQueryArgsForCall)]
	fake.listAppsByQueryArgsForCall = append(fake.listAppsByQueryArgsForCall, struct {
		arg1 url.Values
	}{arg1})
	stub := fake.ListAppsByQueryStub
	fakeReturns := fake.listAppsByQueryReturns
	fake.recordInvocation("ListAppsByQuery", []interface{}{arg1})
	fake.listAppsByQueryMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) ListAppsByQueryCallCount() int {
	fake.listAppsByQueryMutex.RLock()
	defer fake.listAppsByQueryMutex.RUnlock()
	return len(fake.listAppsByQueryArgsForCall)
}

func (fake *FakeClient) ListAppsByQueryCalls(stub func(url.Values) ([]cfclient.App, error)) {
	fake.listAppsByQueryMutex.Lock()
	defer fake.listAppsByQueryMutex.Unlock()
	fake.ListAppsByQueryStub = stub
}

func (fake *FakeClient) ListAppsByQueryArgsForCall(i int) url.Values {
	fake.listAppsByQueryMutex.RLock()
	defer fake.listAppsByQueryMutex.RUnlock()
	argsForCall := fake.listAppsByQueryArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) ListAppsByQueryReturns(result1 []cfclient.App, result2 error) {
	fake.listAppsByQueryMutex.Lock()
	defer fake.listAppsByQueryMutex.Unlock()
	fake.ListAppsByQueryStub = nil
	fake.listAppsByQueryReturns = struct {
		result1 []cfclient.App
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListAppsByQueryReturnsOnCall(i int, result1 []cfclient.App, result2 error) {
	fake.listAppsByQueryMutex.Lock()
	defer fake.listAppsByQueryMutex.Unlock()
	fake.ListAppsByQueryStub = nil
	if fake.listAppsByQueryReturnsOnCall == nil {
		fake.listAppsByQueryReturnsOnCall = make(map[int]struct {
			result1 []cfclient.App
			result2 error
		})
	}
	fake.listAppsByQueryReturnsOnCall[i] = struct {
		result1 []cfclient.App
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListOrgs() ([]cfclient.Org, error) {
	fake.listOrgsMutex.Lock()
	ret, specificReturn := fake.listOrgsReturnsOnCall[len(fake.listOrgsArgsForCall)]
	fake.listOrgsArgsForCall = append(fake.listOrgsArgsForCall, struct {
	}{})
	stub := fake.ListOrgsStub
	fakeReturns := fake.listOrgsReturns
	fake.recordInvocation("ListOrgs", []interface{}{})
	fake.listOrgsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) ListOrgsCallCount() int {
	fake.listOrgsMutex.RLock()
	defer fake.listOrgsMutex.RUnlock()
	return len(fake.listOrgsArgsForCall)
}

func (fake *FakeClient) ListOrgsCalls(stub func() ([]cfclient.Org, error)) {
	fake.listOrgsMutex.Lock()
	defer fake.listOrgsMutex.Unlock()
	fake.ListOrgsStub = stub
}

func (fake *FakeClient) ListOrgsReturns(result1 []cfclient.Org, result2 error) {
	fake.listOrgsMutex.Lock()
	defer fake.listOrgsMutex.Unlock()
	fake.ListOrgsStub = nil
	fake.listOrgsReturns = struct {
		result1 []cfclient.Org
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListOrgsReturnsOnCall(i int, result1 []cfclient.Org, result2 error) {
	fake.listOrgsMutex.Lock()
	defer fake.listOrgsMutex.Unlock()
	fake.ListOrgsStub = nil
	if fake.listOrgsReturnsOnCall == nil {
		fake.listOrgsReturnsOnCall = make(map[int]struct {
			result1 []cfclient.Org
			result2 error
		})
	}
	fake.listOrgsReturnsOnCall[i] = struct {
		result1 []cfclient.Org
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListOrgsByQuery(arg1 url.Values) ([]cfclient.Org, error) {
	fake.listOrgsByQueryMutex.Lock()
	ret, specificReturn := fake.listOrgsByQueryReturnsOnCall[len(fake.listOrgsByQueryArgsForCall)]
	fake.listOrgsByQueryArgsForCall = append(fake.listOrgsByQueryArgsForCall, struct {
		arg1 url.Values
	}{arg1})
	stub := fake.ListOrgsByQueryStub
	fakeReturns := fake.listOrgsByQueryReturns
	fake.recordInvocation("ListOrgsByQuery", []interface{}{arg1})
	fake.listOrgsByQueryMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) ListOrgsByQueryCallCount() int {
	fake.listOrgsByQueryMutex.RLock()
	defer fake.listOrgsByQueryMutex.RUnlock()
	return len(fake.listOrgsByQueryArgsForCall)
}

func (fake *FakeClient) ListOrgsByQueryCalls(stub func(url.Values) ([]cfclient.Org, error)) {
	fake.listOrgsByQueryMutex.Lock()
	defer fake.listOrgsByQueryMutex.Unlock()
	fake.ListOrgsByQueryStub = stub
}

func (fake *FakeClient) ListOrgsByQueryArgsForCall(i int) url.Values {
	fake.listOrgsByQueryMutex.RLock()
	defer fake.listOrgsByQueryMutex.RUnlock()
	argsForCall := fake.listOrgsByQueryArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) ListOrgsByQueryReturns(result1 []cfclient.Org, result2 error) {
	fake.listOrgsByQueryMutex.Lock()
	defer fake.listOrgsByQueryMutex.Unlock()
	fake.ListOrgsByQueryStub = nil
	fake.listOrgsByQueryReturns = struct {
		result1 []cfclient.Org
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListOrgsByQueryReturnsOnCall(i int, result1 []cfclient.Org, result2 error) {
	fake.listOrgsByQueryMutex.Lock()
	defer fake.listOrgsByQueryMutex.Unlock()
	fake.ListOrgsByQueryStub = nil
	if fake.listOrgsByQueryReturnsOnCall == nil {
		fake.listOrgsByQueryReturnsOnCall = make(map[int]struct {
			result1 []cfclient.Org
			result2 error
		})
	}
	fake.listOrgsByQueryReturnsOnCall[i] = struct {
		result1 []cfclient.Org
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListRoutesByQuery(arg1 url.Values) ([]cfclient.Route, error) {
	fake.listRoutesByQueryMutex.Lock()
	ret, specificReturn := fake.listRoutesByQueryReturnsOnCall[len(fake.listRoutesByQueryArgsForCall)]
	fake.listRoutesByQueryArgsForCall = append(fake.listRoutesByQueryArgsForCall, struct {
		arg1 url.Values
	}{arg1})
	stub := fake.ListRoutesByQueryStub
	fakeReturns := fake.listRoutesByQueryReturns
	fake.recordInvocation("ListRoutesByQuery", []interface{}{arg1})
	fake.listRoutesByQueryMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) ListRoutesByQueryCallCount() int {
	fake.listRoutesByQueryMutex.RLock()
	defer fake.listRoutesByQueryMutex.RUnlock()
	return len(fake.listRoutesByQueryArgsForCall)
}

func (fake *FakeClient) ListRoutesByQueryCalls(stub func(url.Values) ([]cfclient.Route, error)) {
	fake.listRoutesByQueryMutex.Lock()
	defer fake.listRoutesByQueryMutex.Unlock()
	fake.ListRoutesByQueryStub = stub
}

func (fake *FakeClient) ListRoutesByQueryArgsForCall(i int) url.Values {
	fake.listRoutesByQueryMutex.RLock()
	defer fake.listRoutesByQueryMutex.RUnlock()
	argsForCall := fake.listRoutesByQueryArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) ListRoutesByQueryReturns(result1 []cfclient.Route, result2 error) {
	fake.listRoutesByQueryMutex.Lock()
	defer fake.listRoutesByQueryMutex.Unlock()
	fake.ListRoutesByQueryStub = nil
	fake.listRoutesByQueryReturns = struct {
		result1 []cfclient.Route
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListRoutesByQueryReturnsOnCall(i int, result1 []cfclient.Route, result2 error) {
	fake.listRoutesByQueryMutex.Lock()
	defer fake.listRoutesByQueryMutex.Unlock()
	fake.ListRoutesByQueryStub = nil
	if fake.listRoutesByQueryReturnsOnCall == nil {
		fake.listRoutesByQueryReturnsOnCall = make(map[int]struct {
			result1 []cfclient.Route
			result2 error
		})
	}
	fake.listRoutesByQueryReturnsOnCall[i] = struct {
		result1 []cfclient.Route
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListServiceInstancesByQuery(arg1 url.Values) ([]cfclient.ServiceInstance, error) {
	fake.listServiceInstancesByQueryMutex.Lock()
	ret, specificReturn := fake.listServiceInstancesByQueryReturnsOnCall[len(fake.listServiceInstancesByQueryArgsForCall)]
	fake.listServiceInstancesByQueryArgsForCall = append(fake.listServiceInstancesByQueryArgsForCall, struct {
		arg1 url.Values
	}{arg1})
	stub := fake.ListServiceInstancesByQueryStub
	fakeReturns := fake.listServiceInstancesByQueryReturns
	fake.recordInvocation("ListServiceInstancesByQuery", []interface{}{arg1})
	fake.listServiceInstancesByQueryMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) ListServiceInstancesByQueryCallCount() int {
	fake.listServiceInstancesByQueryMutex.RLock()
	defer fake.listServiceInstancesByQueryMutex.RUnlock()
	return len(fake.listServiceInstancesByQueryArgsForCall)
}

func (fake *FakeClient) ListServiceInstancesByQueryCalls(stub func(url.Values) ([]cfclient.ServiceInstance, error)) {
	fake.listServiceInstancesByQueryMutex.Lock()
	defer fake.listServiceInstancesByQueryMutex.Unlock()
	fake.ListServiceInstancesByQueryStub = stub
}

func (fake *FakeClient) ListServiceInstancesByQueryArgsForCall(i int) url.Values {
	fake.listServiceInstancesByQueryMutex.RLock()
	defer fake.listServiceInstancesByQueryMutex.RUnlock()
	argsForCall := fake.listServiceInstancesByQueryArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) ListServiceInstancesByQueryReturns(result1 []cfclient.ServiceInstance, result2 error) {
	fake.listServiceInstancesByQueryMutex.Lock()
	defer fake.listServiceInstancesByQueryMutex.Unlock()
	fake.ListServiceInstancesByQueryStub = nil
	fake.listServiceInstancesByQueryReturns = struct {
		result1 []cfclient.ServiceInstance
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListServiceInstancesByQueryReturnsOnCall(i int, result1 []cfclient.ServiceInstance, result2 error) {
	fake.listServiceInstancesByQueryMutex.Lock()
	defer fake.listServiceInstancesByQueryMutex.Unlock()
	fake.ListServiceInstancesByQueryStub = nil
	if fake.listServiceInstancesByQueryReturnsOnCall == nil {
		fake.listServiceInstancesByQueryReturnsOnCall = make(map[int]struct {
			result1 []cfclient.ServiceInstance
			result2 error
		})
	}
	fake.listServiceInstancesByQueryReturnsOnCall[i] = struct {
		result1 []cfclient.ServiceInstance
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListSpaces() ([]cfclient.Space, error) {
	fake.listSpacesMutex.Lock()
	ret, specificReturn := fake.listSpacesReturnsOnCall[len(fake.listSpacesArgsForCall)]
	fake.listSpacesArgsForCall = append(fake.listSpacesArgsForCall, struct {
	}{})
	stub := fake.ListSpacesStub
	fakeReturns := fake.listSpacesReturns
	fake.recordInvocation("ListSpaces", []interface{}{})
	fake.listSpacesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) ListSpacesCallCount() int {
	fake.listSpacesMutex.RLock()
	defer fake.listSpacesMutex.RUnlock()
	return len(fake.listSpacesArgsForCall)
}

func (fake *FakeClient) ListSpacesCalls(stub func() ([]cfclient.Space, error)) {
	fake.listSpacesMutex.Lock()
	defer fake.listSpacesMutex.Unlock()
	fake.ListSpacesStub = stub
}

func (fake *FakeClient) ListSpacesReturns(result1 []cfclient.Space, result2 error) {
	fake.listSpacesMutex.Lock()
	defer fake.listSpacesMutex.Unlock()
	fake.ListSpacesStub = nil
	fake.listSpacesReturns = struct {
		result1 []cfclient.Space
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListSpacesReturnsOnCall(i int, result1 []cfclient.Space, result2 error) {
	fake.listSpacesMutex.Lock()
	defer fake.listSpacesMutex.Unlock()
	fake.ListSpacesStub = nil
	if fake.listSpacesReturnsOnCall == nil {
		fake.listSpacesReturnsOnCall = make(map[int]struct {
			result1 []cfclient.Space
			result2 error
		})
	}
	fake.listSpacesReturnsOnCall[i] = struct {
		result1 []cfclient.Space
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListSpacesByQuery(arg1 url.Values) ([]cfclient.Space, error) {
	fake.listSpacesByQueryMutex.Lock()
	ret, specificReturn := fake.listSpacesByQueryReturnsOnCall[len(fake.listSpacesByQueryArgsForCall)]
	fake.listSpacesByQueryArgsForCall = append(fake.listSpacesByQueryArgsForCall, struct {
		arg1 url.Values
	}{arg1})
	stub := fake.ListSpacesByQueryStub
	fakeReturns := fake.listSpacesByQueryReturns
	fake.recordInvocation("ListSpacesByQuery", []interface{}{arg1})
	fake.listSpacesByQueryMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) ListSpacesByQueryCallCount() int {
	fake.listSpacesByQueryMutex.RLock()
	defer fake.listSpacesByQueryMutex.RUnlock()
	return len(fake.listSpacesByQueryArgsForCall)
}

func (fake *FakeClient) ListSpacesByQueryCalls(stub func(url.Values) ([]cfclient.Space, error)) {
	fake.listSpacesByQueryMutex.Lock()
	defer fake.listSpacesByQueryMutex.Unlock()
	fake.ListSpacesByQueryStub = stub
}

func (fake *FakeClient) ListSpacesByQueryArgsForCall(i int) url.Values {
	fake.listSpacesByQueryMutex.RLock()
	defer fake.listSpacesByQueryMutex.RUnlock()
	argsForCall := fake.listSpacesByQueryArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) ListSpacesByQueryReturns(result1 []cfclient.Space, result2 error) {
	fake.listSpacesByQueryMutex.Lock()
	defer fake.listSpacesByQueryMutex.Unlock()
	fake.ListSpacesByQueryStub = nil
	fake.listSpacesByQueryReturns = struct {
		result1 []cfclient.Space
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListSpacesByQueryReturnsOnCall(i int, result1 []cfclient.Space, result2 error) {
	fake.listSpacesByQueryMutex.Lock()
	defer fake.listSpacesByQueryMutex.Unlock()
	fake.ListSpacesByQueryStub = nil
	if fake.listSpacesByQueryReturnsOnCall == nil {
		fake.listSpacesByQueryReturnsOnCall = make(map[int]struct {
			result1 []cfclient.Space
			result2 error
		})
	}
	fake.listSpacesByQueryReturnsOnCall[i] = struct {
		result1 []cfclient.Space
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListStacksByQuery(arg1 url.Values) ([]cfclient.Stack, error) {
	fake.listStacksByQueryMutex.Lock()
	ret, specificReturn := fake.listStacksByQueryReturnsOnCall[len(fake.listStacksByQueryArgsForCall)]
	fake.listStacksByQueryArgsForCall = append(fake.listStacksByQueryArgsForCall, struct {
		arg1 url.Values
	}{arg1})
	stub := fake.ListStacksByQueryStub
	fakeReturns := fake.listStacksByQueryReturns
	fake.recordInvocation("ListStacksByQuery", []interface{}{arg1})
	fake.listStacksByQueryMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) ListStacksByQueryCallCount() int {
	fake.listStacksByQueryMutex.RLock()
	defer fake.listStacksByQueryMutex.RUnlock()
	return len(fake.listStacksByQueryArgsForCall)
}

func (fake *FakeClient) ListStacksByQueryCalls(stub func(url.Values) ([]cfclient.Stack, error)) {
	fake.listStacksByQueryMutex.Lock()
	defer fake.listStacksByQueryMutex.Unlock()
	fake.ListStacksByQueryStub = stub
}

func (fake *FakeClient) ListStacksByQueryArgsForCall(i int) url.Values {
	fake.listStacksByQueryMutex.RLock()
	defer fake.listStacksByQueryMutex.RUnlock()
	argsForCall := fake.listStacksByQueryArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) ListStacksByQueryReturns(result1 []cfclient.Stack, result2 error) {
	fake.listStacksByQueryMutex.Lock()
	defer fake.listStacksByQueryMutex.Unlock()
	fake.ListStacksByQueryStub = nil
	fake.listStacksByQueryReturns = struct {
		result1 []cfclient.Stack
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListStacksByQueryReturnsOnCall(i int, result1 []cfclient.Stack, result2 error) {
	fake.listStacksByQueryMutex.Lock()
	defer fake.listStacksByQueryMutex.Unlock()
	fake.ListStacksByQueryStub = nil
	if fake.listStacksByQueryReturnsOnCall == nil {
		fake.listStacksByQueryReturnsOnCall = make(map[int]struct {
			result1 []cfclient.Stack
			result2 error
		})
	}
	fake.listStacksByQueryReturnsOnCall[i] = struct {
		result1 []cfclient.Stack
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListUserProvidedServiceInstancesByQuery(arg1 url.Values) ([]cfclient.UserProvidedServiceInstance, error) {
	fake.listUserProvidedServiceInstancesByQueryMutex.Lock()
	ret, specificReturn := fake.listUserProvidedServiceInstancesByQueryReturnsOnCall[len(fake.listUserProvidedServiceInstancesByQueryArgsForCall)]
	fake.listUserProvidedServiceInstancesByQueryArgsForCall = append(fake.listUserProvidedServiceInstancesByQueryArgsForCall, struct {
		arg1 url.Values
	}{arg1})
	stub := fake.ListUserProvidedServiceInstancesByQueryStub
	fakeReturns := fake.listUserProvidedServiceInstancesByQueryReturns
	fake.recordInvocation("ListUserProvidedServiceInstancesByQuery", []interface{}{arg1})
	fake.listUserProvidedServiceInstancesByQueryMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) ListUserProvidedServiceInstancesByQueryCallCount() int {
	fake.listUserProvidedServiceInstancesByQueryMutex.RLock()
	defer fake.listUserProvidedServiceInstancesByQueryMutex.RUnlock()
	return len(fake.listUserProvidedServiceInstancesByQueryArgsForCall)
}

func (fake *FakeClient) ListUserProvidedServiceInstancesByQueryCalls(stub func(url.Values) ([]cfclient.UserProvidedServiceInstance, error)) {
	fake.listUserProvidedServiceInstancesByQueryMutex.Lock()
	defer fake.listUserProvidedServiceInstancesByQueryMutex.Unlock()
	fake.ListUserProvidedServiceInstancesByQueryStub = stub
}

func (fake *FakeClient) ListUserProvidedServiceInstancesByQueryArgsForCall(i int) url.Values {
	fake.listUserProvidedServiceInstancesByQueryMutex.RLock()
	defer fake.listUserProvidedServiceInstancesByQueryMutex.RUnlock()
	argsForCall := fake.listUserProvidedServiceInstancesByQueryArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) ListUserProvidedServiceInstancesByQueryReturns(result1 []cfclient.UserProvidedServiceInstance, result2 error) {
	fake.listUserProvidedServiceInstancesByQueryMutex.Lock()
	defer fake.listUserProvidedServiceInstancesByQueryMutex.Unlock()
	fake.ListUserProvidedServiceInstancesByQueryStub = nil
	fake.listUserProvidedServiceInstancesByQueryReturns = struct {
		result1 []cfclient.UserProvidedServiceInstance
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListUserProvidedServiceInstancesByQueryReturnsOnCall(i int, result1 []cfclient.UserProvidedServiceInstance, result2 error) {
	fake.listUserProvidedServiceInstancesByQueryMutex.Lock()
	defer fake.listUserProvidedServiceInstancesByQueryMutex.Unlock()
	fake.ListUserProvidedServiceInstancesByQueryStub = nil
	if fake.listUserProvidedServiceInstancesByQueryReturnsOnCall == nil {
		fake.listUserProvidedServiceInstancesByQueryReturnsOnCall = make(map[int]struct {
			result1 []cfclient.UserProvidedServiceInstance
			result2 error
		})
	}
	fake.listUserProvidedServiceInstancesByQueryReturnsOnCall[i] = struct {
		result1 []cfclient.UserProvidedServiceInstance
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) NewRequest(arg1 string, arg2 string) *cfclient.Request {
	fake.newRequestMutex.Lock()
	ret, specificReturn := fake.newRequestReturnsOnCall[len(fake.newRequestArgsForCall)]
	fake.newRequestArgsForCall = append(fake.newRequestArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.NewRequestStub
	fakeReturns := fake.newRequestReturns
	fake.recordInvocation("NewRequest", []interface{}{arg1, arg2})
	fake.newRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) NewRequestCallCount() int {
	fake.newRequestMutex.RLock()
	defer fake.newRequestMutex.RUnlock()
	return len(fake.newRequestArgsForCall)
}

func (fake *FakeClient) NewRequestCalls(stub func(string, string) *cfclient.Request) {
	fake.newRequestMutex.Lock()
	defer fake.newRequestMutex.Unlock()
	fake.NewRequestStub = stub
}

func (fake *FakeClient) NewRequestArgsForCall(i int) (string, string) {
	fake.newRequestMutex.RLock()
	defer fake.newRequestMutex.RUnlock()
	argsForCall := fake.newRequestArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) NewRequestReturns(result1 *cfclient.Request) {
	fake.newRequestMutex.Lock()
	defer fake.newRequestMutex.Unlock()
	fake.NewRequestStub = nil
	fake.newRequestReturns = struct {
		result1 *cfclient.Request
	}{result1}
}

func (fake *FakeClient) NewRequestReturnsOnCall(i int, result1 *cfclient.Request) {
	fake.newRequestMutex.Lock()
	defer fake.newRequestMutex.Unlock()
	fake.NewRequestStub = nil
	if fake.newRequestReturnsOnCall == nil {
		fake.newRequestReturnsOnCall = make(map[int]struct {
			result1 *cfclient.Request
		})
	}
	fake.newRequestReturnsOnCall[i] = struct {
		result1 *cfclient.Request
	}{result1}
}

func (fake *FakeClient) NewRequestWithBody(arg1 string, arg2 string, arg3 io.Reader) *cfclient.Request {
	fake.newRequestWithBodyMutex.Lock()
	ret, specificReturn := fake.newRequestWithBodyReturnsOnCall[len(fake.newRequestWithBodyArgsForCall)]
	fake.newRequestWithBodyArgsForCall = append(fake.newRequestWithBodyArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 io.Reader
	}{arg1, arg2, arg3})
	stub := fake.NewRequestWithBodyStub
	fakeReturns := fake.newRequestWithBodyReturns
	fake.recordInvocation("NewRequestWithBody", []interface{}{arg1, arg2, arg3})
	fake.newRequestWithBodyMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) NewRequestWithBodyCallCount() int {
	fake.newRequestWithBodyMutex.RLock()
	defer fake.newRequestWithBodyMutex.RUnlock()
	return len(fake.newRequestWithBodyArgsForCall)
}

func (fake *FakeClient) NewRequestWithBodyCalls(stub func(string, string, io.Reader) *cfclient.Request) {
	fake.newRequestWithBodyMutex.Lock()
	defer fake.newRequestWithBodyMutex.Unlock()
	fake.NewRequestWithBodyStub = stub
}

func (fake *FakeClient) NewRequestWithBodyArgsForCall(i int) (string, string, io.Reader) {
	fake.newRequestWithBodyMutex.RLock()
	defer fake.newRequestWithBodyMutex.RUnlock()
	argsForCall := fake.newRequestWithBodyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) NewRequestWithBodyReturns(result1 *cfclient.Request) {
	fake.newRequestWithBodyMutex.Lock()
	defer fake.newRequestWithBodyMutex.Unlock()
	fake.NewRequestWithBodyStub = nil
	fake.newRequestWithBodyReturns = struct {
		result1 *cfclient.Request
	}{result1}
}

func (fake *FakeClient) NewRequestWithBodyReturnsOnCall(i int, result1 *cfclient.Request) {
	fake.newRequestWithBodyMutex.Lock()
	defer fake.newRequestWithBodyMutex.Unlock()
	fake.NewRequestWithBodyStub = nil
	if fake.newRequestWithBodyReturnsOnCall == nil {
		fake.newRequestWithBodyReturnsOnCall = make(map[int]struct {
			result1 *cfclient.Request
		})
	}
	fake.newRequestWithBodyReturnsOnCall[i] = struct {
		result1 *cfclient.Request
	}{result1}
}

func (fake *FakeClient) Target() string {
	fake.targetMutex.Lock()
	ret, specificReturn := fake.targetReturnsOnCall[len(fake.targetArgsForCall)]
	fake.targetArgsForCall = append(fake.targetArgsForCall, struct {
	}{})
	stub := fake.TargetStub
	fakeReturns := fake.targetReturns
	fake.recordInvocation("Target", []interface{}{})
	fake.targetMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TargetCallCount() int {
	fake.targetMutex.RLock()
	defer fake.targetMutex.RUnlock()
	return len(fake.targetArgsForCall)
}

func (fake *FakeClient) TargetCalls(stub func() string) {
	fake.targetMutex.Lock()
	defer fake.targetMutex.Unlock()
	fake.TargetStub = stub
}

func (fake *FakeClient) TargetReturns(result1 string) {
	fake.targetMutex.Lock()
	defer fake.targetMutex.Unlock()
	fake.TargetStub = nil
	fake.targetReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeClient) TargetReturnsOnCall(i int, result1 string) {
	fake.targetMutex.Lock()
	defer fake.targetMutex.Unlock()
	fake.TargetStub = nil
	if fake.targetReturnsOnCall == nil {
		fake.targetReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.targetReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeClient) UpdateApp(arg1 string, arg2 cfclient.AppUpdateResource) (cfclient.UpdateResponse, error) {
	fake.updateAppMutex.Lock()
	ret, specificReturn := fake.updateAppReturnsOnCall[len(fake.updateAppArgsForCall)]
	fake.updateAppArgsForCall = append(fake.updateAppArgsForCall, struct {
		arg1 string
		arg2 cfclient.AppUpdateResource
	}{arg1, arg2})
	stub := fake.UpdateAppStub
	fakeReturns := fake.updateAppReturns
	fake.recordInvocation("UpdateApp", []interface{}{arg1, arg2})
	fake.updateAppMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) UpdateAppCallCount() int {
	fake.updateAppMutex.RLock()
	defer fake.updateAppMutex.RUnlock()
	return len(fake.updateAppArgsForCall)
}

func (fake *FakeClient) UpdateAppCalls(stub func(string, cfclient.AppUpdateResource) (cfclient.UpdateResponse, error)) {
	fake.updateAppMutex.Lock()
	defer fake.updateAppMutex.Unlock()
	fake.UpdateAppStub = stub
}

func (fake *FakeClient) UpdateAppArgsForCall(i int) (string, cfclient.AppUpdateResource) {
	fake.updateAppMutex.RLock()
	defer fake.updateAppMutex.RUnlock()
	argsForCall := fake.updateAppArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) UpdateAppReturns(result1 cfclient.UpdateResponse, result2 error) {
	fake.updateAppMutex.Lock()
	defer fake.updateAppMutex.Unlock()
	fake.UpdateAppStub = nil
	fake.updateAppReturns = struct {
		result1 cfclient.UpdateResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) UpdateAppReturnsOnCall(i int, result1 cfclient.UpdateResponse, result2 error) {
	fake.updateAppMutex.Lock()
	defer fake.updateAppMutex.Unlock()
	fake.UpdateAppStub = nil
	if fake.updateAppReturnsOnCall == nil {
		fake.updateAppReturnsOnCall = make(map[int]struct {
			result1 cfclient.UpdateResponse
			result2 error
		})
	}
	fake.updateAppReturnsOnCall[i] = struct {
		result1 cfclient.UpdateResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) UpdateV3App(arg1 string, arg2 cfclient.UpdateV3AppRequest) (*cfclient.V3App, error) {
	fake.updateV3AppMutex.Lock()
	ret, specificReturn := fake.updateV3AppReturnsOnCall[len(fake.updateV3AppArgsForCall)]
	fake.updateV3AppArgsForCall = append(fake.updateV3AppArgsForCall, struct {
		arg1 string
		arg2 cfclient.UpdateV3AppRequest
	}{arg1, arg2})
	stub := fake.UpdateV3AppStub
	fakeReturns := fake.updateV3AppReturns
	fake.recordInvocation("UpdateV3App", []interface{}{arg1, arg2})
	fake.updateV3AppMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) UpdateV3AppCallCount() int {
	fake.updateV3AppMutex.RLock()
	defer fake.updateV3AppMutex.RUnlock()
	return len(fake.updateV3AppArgsForCall)
}

func (fake *FakeClient) UpdateV3AppCalls(stub func(string, cfclient.UpdateV3AppRequest) (*cfclient.V3App, error)) {
	fake.updateV3AppMutex.Lock()
	defer fake.updateV3AppMutex.Unlock()
	fake.UpdateV3AppStub = stub
}

func (fake *FakeClient) UpdateV3AppArgsForCall(i int) (string, cfclient.UpdateV3AppRequest) {
	fake.updateV3AppMutex.RLock()
	defer fake.updateV3AppMutex.RUnlock()
	argsForCall := fake.updateV3AppArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) UpdateV3AppReturns(result1 *cfclient.V3App, result2 error) {
	fake.updateV3AppMutex.Lock()
	defer fake.updateV3AppMutex.Unlock()
	fake.UpdateV3AppStub = nil
	fake.updateV3AppReturns = struct {
		result1 *cfclient.V3App
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) UpdateV3AppReturnsOnCall(i int, result1 *cfclient.V3App, result2 error) {
	fake.updateV3AppMutex.Lock()
	defer fake.updateV3AppMutex.Unlock()
	fake.UpdateV3AppStub = nil
	if fake.updateV3AppReturnsOnCall == nil {
		fake.updateV3AppReturnsOnCall = make(map[int]struct {
			result1 *cfclient.V3App
			result2 error
		})
	}
	fake.updateV3AppReturnsOnCall[i] = struct {
		result1 *cfclient.V3App
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) UploadAppBits(arg1 io.Reader, arg2 string) error {
	fake.uploadAppBitsMutex.Lock()
	ret, specificReturn := fake.uploadAppBitsReturnsOnCall[len(fake.uploadAppBitsArgsForCall)]
	fake.uploadAppBitsArgsForCall = append(fake.uploadAppBitsArgsForCall, struct {
		arg1 io.Reader
		arg2 string
	}{arg1, arg2})
	stub := fake.UploadAppBitsStub
	fakeReturns := fake.uploadAppBitsReturns
	fake.recordInvocation("UploadAppBits", []interface{}{arg1, arg2})
	fake.uploadAppBitsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) UploadAppBitsCallCount() int {
	fake.uploadAppBitsMutex.RLock()
	defer fake.uploadAppBitsMutex.RUnlock()
	return len(fake.uploadAppBitsArgsForCall)
}

func (fake *FakeClient) UploadAppBitsCalls(stub func(io.Reader, string) error) {
	fake.uploadAppBitsMutex.Lock()
	defer fake.uploadAppBitsMutex.Unlock()
	fake.UploadAppBitsStub = stub
}

func (fake *FakeClient) UploadAppBitsArgsForCall(i int) (io.Reader, string) {
	fake.uploadAppBitsMutex.RLock()
	defer fake.uploadAppBitsMutex.RUnlock()
	argsForCall := fake.uploadAppBitsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) UploadAppBitsReturns(result1 error) {
	fake.uploadAppBitsMutex.Lock()
	defer fake.uploadAppBitsMutex.Unlock()
	fake.UploadAppBitsStub = nil
	fake.uploadAppBitsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) UploadAppBitsReturnsOnCall(i int, result1 error) {
	fake.uploadAppBitsMutex.Lock()
	defer fake.uploadAppBitsMutex.Unlock()
	fake.UploadAppBitsStub = nil
	if fake.uploadAppBitsReturnsOnCall == nil {
		fake.uploadAppBitsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.uploadAppBitsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) UploadDropletBits(arg1 io.Reader, arg2 string) (string, error) {
	fake.uploadDropletBitsMutex.Lock()
	ret, specificReturn := fake.uploadDropletBitsReturnsOnCall[len(fake.uploadDropletBitsArgsForCall)]
	fake.uploadDropletBitsArgsForCall = append(fake.uploadDropletBitsArgsForCall, struct {
		arg1 io.Reader
		arg2 string
	}{arg1, arg2})
	stub := fake.UploadDropletBitsStub
	fakeReturns := fake.uploadDropletBitsReturns
	fake.recordInvocation("UploadDropletBits", []interface{}{arg1, arg2})
	fake.uploadDropletBitsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) UploadDropletBitsCallCount() int {
	fake.uploadDropletBitsMutex.RLock()
	defer fake.uploadDropletBitsMutex.RUnlock()
	return len(fake.uploadDropletBitsArgsForCall)
}

func (fake *FakeClient) UploadDropletBitsCalls(stub func(io.Reader, string) (string, error)) {
	fake.uploadDropletBitsMutex.Lock()
	defer fake.uploadDropletBitsMutex.Unlock()
	fake.UploadDropletBitsStub = stub
}

func (fake *FakeClient) UploadDropletBitsArgsForCall(i int) (io.Reader, string) {
	fake.uploadDropletBitsMutex.RLock()
	defer fake.uploadDropletBitsMutex.RUnlock()
	argsForCall := fake.uploadDropletBitsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) UploadDropletBitsReturns(result1 string, result2 error) {
	fake.uploadDropletBitsMutex.Lock()
	defer fake.uploadDropletBitsMutex.Unlock()
	fake.UploadDropletBitsStub = nil
	fake.uploadDropletBitsReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) UploadDropletBitsReturnsOnCall(i int, result1 string, result2 error) {
	fake.uploadDropletBitsMutex.Lock()
	defer fake.uploadDropletBitsMutex.Unlock()
	fake.UploadDropletBitsStub = nil
	if fake.uploadDropletBitsReturnsOnCall == nil {
		fake.uploadDropletBitsReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.uploadDropletBitsReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.appByNameMutex.RLock()
	defer fake.appByNameMutex.RUnlock()
	fake.bindRouteMutex.RLock()
	defer fake.bindRouteMutex.RUnlock()
	fake.createAppMutex.RLock()
	defer fake.createAppMutex.RUnlock()
	fake.createOrgMutex.RLock()
	defer fake.createOrgMutex.RUnlock()
	fake.createRouteMutex.RLock()
	defer fake.createRouteMutex.RUnlock()
	fake.createServiceBindingMutex.RLock()
	defer fake.createServiceBindingMutex.RUnlock()
	fake.createSpaceMutex.RLock()
	defer fake.createSpaceMutex.RUnlock()
	fake.deleteAppMutex.RLock()
	defer fake.deleteAppMutex.RUnlock()
	fake.deleteOrgMutex.RLock()
	defer fake.deleteOrgMutex.RUnlock()
	fake.doMutex.RLock()
	defer fake.doMutex.RUnlock()
	fake.doRequestMutex.RLock()
	defer fake.doRequestMutex.RUnlock()
	fake.doWithRetryMutex.RLock()
	defer fake.doWithRetryMutex.RUnlock()
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	fake.getAppByGuidNoInlineCallMutex.RLock()
	defer fake.getAppByGuidNoInlineCallMutex.RUnlock()
	fake.getClientConfigMutex.RLock()
	defer fake.getClientConfigMutex.RUnlock()
	fake.getDomainByNameMutex.RLock()
	defer fake.getDomainByNameMutex.RUnlock()
	fake.getOrgByGuidMutex.RLock()
	defer fake.getOrgByGuidMutex.RUnlock()
	fake.getOrgByNameMutex.RLock()
	defer fake.getOrgByNameMutex.RUnlock()
	fake.getOrgQuotaByNameMutex.RLock()
	defer fake.getOrgQuotaByNameMutex.RUnlock()
	fake.getSharedDomainByNameMutex.RLock()
	defer fake.getSharedDomainByNameMutex.RUnlock()
	fake.getSpaceByGuidMutex.RLock()
	defer fake.getSpaceByGuidMutex.RUnlock()
	fake.getSpaceByNameMutex.RLock()
	defer fake.getSpaceByNameMutex.RUnlock()
	fake.getStackByGuidMutex.RLock()
	defer fake.getStackByGuidMutex.RUnlock()
	fake.hTTPClientMutex.RLock()
	defer fake.hTTPClientMutex.RUnlock()
	fake.listAppsByQueryMutex.RLock()
	defer fake.listAppsByQueryMutex.RUnlock()
	fake.listOrgsMutex.RLock()
	defer fake.listOrgsMutex.RUnlock()
	fake.listOrgsByQueryMutex.RLock()
	defer fake.listOrgsByQueryMutex.RUnlock()
	fake.listRoutesByQueryMutex.RLock()
	defer fake.listRoutesByQueryMutex.RUnlock()
	fake.listServiceInstancesByQueryMutex.RLock()
	defer fake.listServiceInstancesByQueryMutex.RUnlock()
	fake.listSpacesMutex.RLock()
	defer fake.listSpacesMutex.RUnlock()
	fake.listSpacesByQueryMutex.RLock()
	defer fake.listSpacesByQueryMutex.RUnlock()
	fake.listStacksByQueryMutex.RLock()
	defer fake.listStacksByQueryMutex.RUnlock()
	fake.listUserProvidedServiceInstancesByQueryMutex.RLock()
	defer fake.listUserProvidedServiceInstancesByQueryMutex.RUnlock()
	fake.newRequestMutex.RLock()
	defer fake.newRequestMutex.RUnlock()
	fake.newRequestWithBodyMutex.RLock()
	defer fake.newRequestWithBodyMutex.RUnlock()
	fake.targetMutex.RLock()
	defer fake.targetMutex.RUnlock()
	fake.updateAppMutex.RLock()
	defer fake.updateAppMutex.RUnlock()
	fake.updateV3AppMutex.RLock()
	defer fake.updateV3AppMutex.RUnlock()
	fake.uploadAppBitsMutex.RLock()
	defer fake.uploadAppBitsMutex.RUnlock()
	fake.uploadDropletBitsMutex.RLock()
	defer fake.uploadDropletBitsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ cf.Client = new(FakeClient)
